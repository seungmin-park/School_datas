# 기말고사 대비 PPT 내용 정리

### UML의 역할

소프투웨어의 전체를 판단할 수 있도록 12개의 다이어그램을 제시한다.

### 유스케이스

사용자가 시스템을 통해 사용하고 싶은기능

유스케이슫가 모여 하나의 서브시스템을 이루며, 서브시스템이 모여 개발 시스템이 됨

`전체 시스템은 유스케이스를 모아 놓은것과 같아야 한다`

`시스템이 아니라 수작업으로 이루어진 것은 유스케이스에 포함하면 안된다`

### 액터

일반화: 개별적인 것에서 공통적인 특징을 뽑아 이름을 붙인 것 <-> 특수화

### 클래스 다이어그램

소프트웨어의 기본 구성 단위인 시스템에서 사용하는 클래스르 정의

클래스들이 서로 어떻게 연결되어 있고 어떤 역할을 하는지 다이어그램으로 표현한다.

### 순차 다이어그램

실행 시점에 객체들이 어떻게 상호 동작하는지르 메세지 순서에 초점을 맞춰 나타낸것

### 통신 다이어그램

객체 간 상호작용 관계에 주목하며, 화살표 위에 적힌 번호로 순서를 알 수 있다.

### 활동 다이어그램

흐름도와 비슷하나 객체의 행위를 나타낸다는 점에서 다르다.

상위 수준에서는 업무의 흐름을 표현하고 분석 단계에서는 유스케이스의 구체적인 흐름을 나타난다.

설계 단계에서는 클래스 내부 동작에 대한 알고리즘이나 구체적인 로직을 표현한다.

### 상태 다이어그램

이벤트 발생이나 시간의 흐름에 따라 바뀌는 객체의 상태를 나타난다.

### 컴포넌트 다이어그램

구현 관점에서 정적 모델링을 할 때 사용하는 것으로 어떤 실행 모듈이 존재하고 이들이 서로 어떤 연관성이 있는지의 종속 관계를 나타낸다.

### 배치 다이어그램

하드웨어 자원을 명시적으로 정의해 시스템의 물리적인 요소를 모델링하고 노드 간의 관계를 나타낸다.

### 객체 다이어그램

클래스 다이어그램과 연관있으며 특정 시점의 오브젝트들의 구조적인 상태를 표현한다.

`오브젝트 -> 클래스의 인스턴스`

### 패키지 다이어그램

과련된 클래스를 패키지로 그루핑하여 복잡한 시스템을 조직화하는데 사용한다.

### 아키텍처

건물의 뼈대뿐만 아니라 특성을 결정짓는 기본 구조를 일컫는 말

#### 특징

소프트웨어의 골격을 나타내는 추상화된 전체 구조를 제공한다.

인터페이스를 통해 소프트웨어의 구성 요소가 어떻게 상호작용하는지를 정의

#### 고려 사항

모든 이해관계자 사이의 의사소통 도구로 활용할 수 있어야한다.

### 아키텍처 스타일

#### 데이터 중심형 스타일

주요 데이터가 리포지토리에서 중앙 관리된다.

서스시트템과 리포지토리의 결합도가 높아 리포지토리를 변경하면 서브시슽메에 영향을 줄 수 있다는 단점 존재

#### 클라이언트 서버 스타일

네트워크를 잉요하는 분산시스템 형태로 데이터와 처리 기능을 클라이언트와 서버에 분할해 사용한다.

`서버`

클라이언트에 서비스를 제공하는 역할을 하므로 클라이언트의 요청을 처리하기 위해 대기

`클라이언트`

사용자와 대화하기 위해 서버가 제공하는 서비스를 요청하는 서브시스템

`씬 클라이언트 스타일`

데이터 관리가 서버에서 수행되며 클라이언트는 프레젠테이션 계층만 구현

`팻 클라이언트 스타일`

서버에서 데이터 관리만 하고 애플리케이션 로직과 프레젠테이션의 많은 부분이 클라이언트 쪽에서 구현

#### 계층 스타일

기능을 몇 개의 계층으로 나누어 배치

각 계층의 응집도는 높고 계층 간 결합도는 낮아 재사용 및 유지보수가 용이한 것이 장점이다

`프레젠테이션`

클라이언트 계층으로 사용자와 직접 만나는 화면에 해당된다.

`비즈니스 로직 계층`

기능 요구사항을 구현하는 곳으로 미들웨어라고도 한다.
애플리케이션 로직을 실행하고 또 오떤 형태의 데이터가 필요하고 반환될 것인지를 결정

`데이터 계층`

데이터베이스에 접근해 데이터 처리와 관리를 하며 필요한 데이터를 제공한다.

### MVC 스타일

구성 요소를 기능별 또는 특성별로 명확하게 분리해 유지보수를 쉽게 하고 프로그램의 확장성과 유연성을 높인다.

모델, 뷰, 제어의 세 부분으로 이루어진다.

### 데이터 흐름 스타일(파이프 필터 구조)

서브 시스템이 하나의 데이터를 입력으로 받아서 처리한 후 그 결과를 다음 서브 시스템으로 넘겨주는 과중을 반복

일반적으로 데이터를 변환한는 시스템에서 주로 사용하며, 전체 변환 작업은 독립적인 단계로 나뉠 수 있다.

`필터`

데이터 스트림을 하나 이상 입력 받아 처리후 데이터 스트림 하나를 출력

`파이프`

필터를 거쳐 생성된 데이트 스트림 하나늘 다른 필터의 입력에 연결

### 일반화 관계

`사전적 의미`

일부에 한정되지 아니하고 전체에 걸치는것, 보편적이고 상식적인 것

공통점을가지고 있는 여러 클래스를 묶어서 새로운 클래스르 만들고 공통적인이름을 붙인 것

일반화 관계는 상속 구조, 하위 클래느는 상위 클래스의 모든 것을 상속받아 사용

반대 개념은 구체화 하는 것을 특수화

### 집합 관계

상위 클래스가 하위 클래스로 구성될 때의 관계

```
컴퓨터는 모니터, 본체, 키보드로 이루어졌다.
```

### 합성 관계

집합 관계와 많은 부분이 유사하지만 전체 객체이 완전히 종속되어 독립된 객체로 존재할 수 없다는 것이 다르다.

```
노트북은 모니터, 본체, 키보드로 구성되어있다.
```

### 실체화 관계

특정 클래스에 기능을 추가하기 위해 메서드를 넣을 때 하위 클래스가 상속을 무조건 받아야 하는 사태가 발생

인터페이스 클래스는 메서드의 공통 특성을 묶어 새로운 인터페이스 클래스를 만들고 공통의 이름을 붙힌다.

구체적인 실현은 하위 클래스에서 구현한다.

### 단일 책임 원칙

```
클래스를 변경해야하는 이유는 단 하나여야 한다
```

### 개방 폐쇄 원칙

```
변경에는 닫혀 있어야 하고, 확장에는 열려 있어여 한다.
```

### 리스코프 교체 원칙

```
상위 클래스의 객체는 언제나 자신의 하위 클래스의객체로 교체할 수 있어야 한다.
```

### 의존 관계 역전 원칙

```
클라이언트는 구체 클래스가 아닌 추상 클래스(인터페이스)에 의존해야 한다.
```

### 인터페이스 분리 원칙

```
클라이언트는 자신이 사용하지 않는 메서드와 의존 관계를 맺으면 안 된다.
```

# 7장?

### 표준 코딩 규칙의 장점

높은 가독성 -> 프로그램이 읽기 쉬워 능률이 올라감

간결하고 명확한 코딩 -> 유지보수 향상

개발시간의 단축 -> 개발과정에서 정확도 및 효율의 향상

### 리팩토링

소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것

기능 추가에 신경쓰지않고 코드의 구조에만 관심을 기울인다.

### 기능추가 작업

리팩토링은 신경쓰지 않고 기능 구현을 위하여 코딩하고 테스트하여 잘 동작하는지 확인

### 리팩토링의 목적

소프트웨어의 디자인을 개선시키고 이해하기 쉽게 만든다.

버그를 찾는 데 도움을 주며 프로그램을 빨리 작성할 수 있게 도와준다.

### 리팩토링 프로세스

소규모의 변경 -> 단일 리팩토링

코드가 전부 잘 작동되는지 테스트하고 문제가 없을 시 다음 리팩토링 단계로 전진

작동하지 않으면 문제를 수정하거나 코드를 원상 복구하여 시스템이 작동되도록 유지한다.

### 소프트웨어 테스트의 정의

소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적으로, 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러가지 기술을 이용해 검출하는 작업

```
오류를 찾아내 정상적으로 실행될 수 있도록 하는 정도이지, 소프트웨어에 오류가 없음을 확인시켜주지는 못한다.
```

### 소프트웨어 테스트의 목표

`작은 의미`

원시 코드 속에 남아있는 오류를 발견하는 것

`큰 의미`

개발된 소프트웨어가 고객의 요구를 만족시키는지 확인시켜주는 것

개발된 소프트웨어의 신뢰성을 높여주는것

`오류`

소프트웨어 개발자에 의해 만들어질 수 있는 결함의 원인

`결함`

오류에 의해 프로그램이 완전치 못한 것으로, 고장의 원진

`고장, 실패, 문제, 장애`

시스템이 요구 사항대로 작동하지 않는 것

모든 결함이 반드시 실패를 유발하지는 않는다.
